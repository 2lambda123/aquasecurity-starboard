package vulnerabilityreport

import (
	"context"
	"reflect"

	"k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/types"

	starboardv1alpha1 "github.com/aquasecurity/starboard/pkg/apis/aquasecurity/v1alpha1"
	"github.com/aquasecurity/starboard/pkg/kube"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

type StoreInterface interface {
	Save(context.Context, []starboardv1alpha1.VulnerabilityReport) error
	FindByOwner(context.Context, kube.Object) ([]starboardv1alpha1.VulnerabilityReport, error)
	HasVulnerabilityReports(ctx context.Context, owner kube.Object, hash string, containerImages kube.ContainerImages) (bool, error)
}

type store struct {
	client client.Client
	scheme *runtime.Scheme
}

func NewStore(client client.Client, scheme *runtime.Scheme) StoreInterface {
	return &store{
		client: client,
		scheme: scheme,
	}
}

func (s *store) Save(ctx context.Context, reports []starboardv1alpha1.VulnerabilityReport) error {
	for _, report := range reports {
		err := s.createOrUpdate(ctx, report)
		if err != nil {
			return err
		}
	}
	return nil
}

func (s *store) createOrUpdate(ctx context.Context, report starboardv1alpha1.VulnerabilityReport) error {
	var existing starboardv1alpha1.VulnerabilityReport
	err := s.client.Get(ctx, types.NamespacedName{
		Name:      report.Name,
		Namespace: report.Namespace,
	}, &existing)

	if err == nil {
		copied := existing.DeepCopy()
		copied.Labels = report.Labels
		copied.Report = report.Report

		return s.client.Update(ctx, copied)
	}

	if errors.IsNotFound(err) {
		return s.client.Create(ctx, &report)
	}

	return err
}

func (s *store) FindByOwner(ctx context.Context, owner kube.Object) ([]starboardv1alpha1.VulnerabilityReport, error) {
	var list starboardv1alpha1.VulnerabilityReportList

	err := s.client.List(ctx, &list, client.MatchingLabels{
		kube.LabelResourceKind:      string(owner.Kind),
		kube.LabelResourceNamespace: owner.Namespace,
		kube.LabelResourceName:      owner.Name,
	}, client.InNamespace(owner.Namespace))
	if err != nil {
		return nil, err
	}

	return list.DeepCopy().Items, nil
}

func (s *store) HasVulnerabilityReports(ctx context.Context, owner kube.Object, hash string, containerImages kube.ContainerImages) (bool, error) {
	list, err := s.FindByOwner(ctx, owner)
	if err != nil {
		return false, err
	}

	actual := map[string]bool{}
	for _, report := range list {
		if containerName, ok := report.Labels[kube.LabelContainerName]; ok {
			if hash == report.Labels[kube.LabelPodSpecHash] {
				actual[containerName] = true
			}
		}
	}

	expected := map[string]bool{}
	for containerName, _ := range containerImages {
		expected[containerName] = true
	}

	return reflect.DeepEqual(actual, expected), nil
}
