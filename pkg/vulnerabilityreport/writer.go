package vulnerabilityreport

import (
	"context"

	starboard "github.com/aquasecurity/starboard/pkg/apis/aquasecurity/v1alpha1"
	"k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/labels"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/klog"

	clientset "github.com/aquasecurity/starboard/pkg/generated/clientset/versioned"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

	"github.com/aquasecurity/starboard/pkg/kube"
)

// WorkloadVulnerabilities holds VulnerabilityReports for each container
// of a Kubernetes workload.
type WorkloadVulnerabilities map[string]starboard.VulnerabilityScanResult

type Writer interface {
	Write(ctx context.Context, reports WorkloadVulnerabilities, owner metav1.Object) error
}

type Reader interface {
	Read(ctx context.Context, workload kube.Object) (WorkloadVulnerabilities, error)
}

type ReadWriter interface {
	Reader
	Writer
}

type readWriter struct {
	scheme *runtime.Scheme
	client clientset.Interface
}

func NewReadWriter(scheme *runtime.Scheme, client clientset.Interface) ReadWriter {
	return &readWriter{
		scheme: scheme,
		client: client,
	}
}

func (s *readWriter) Write(ctx context.Context, reports WorkloadVulnerabilities, owner metav1.Object) error {
	for container, report := range reports {
		err := s.createOrUpdate(ctx, container, report, owner)
		if err != nil {
			return err
		}
	}
	return nil
}

func (s *readWriter) createOrUpdate(ctx context.Context, container string, scanResult starboard.VulnerabilityScanResult, owner metav1.Object) error {
	namespace := owner.GetNamespace()

	reportName, err := NewNameBuilder(s.scheme).
		Owner(owner).
		Container(container).Get()

	if err != nil {
		return err
	}

	report, err := s.client.AquasecurityV1alpha1().VulnerabilityReports(owner.GetNamespace()).
		Get(ctx, reportName, metav1.GetOptions{})

	if err == nil && report != nil {
		klog.V(3).Infof("Updating VulnerabilityReport %q", namespace+"/"+reportName)
		deepCopy := report.DeepCopy()
		deepCopy.Report = scanResult
		_, err = s.client.AquasecurityV1alpha1().VulnerabilityReports(namespace).
			Update(ctx, deepCopy, metav1.UpdateOptions{})
		return err
	}

	if errors.IsNotFound(err) {
		klog.V(3).Infof("Creating VulnerabilityReport %q", namespace+"/"+reportName)
		report, err := NewBuilder(s.scheme).
			Owner(owner).
			Container(container).
			ScanResult(scanResult).
			ReportName(reportName).
			Get()
		if err != nil {
			return err
		}
		_, err = s.client.AquasecurityV1alpha1().VulnerabilityReports(namespace).
			Create(ctx, &report, metav1.CreateOptions{})
		return err
	}

	return err
}

func (s *readWriter) Read(ctx context.Context, workload kube.Object) (WorkloadVulnerabilities, error) {
	list, err := s.client.AquasecurityV1alpha1().VulnerabilityReports(workload.Namespace).List(ctx, metav1.ListOptions{
		LabelSelector: labels.Set{
			kube.LabelResourceKind:      string(workload.Kind),
			kube.LabelResourceName:      workload.Name,
			kube.LabelResourceNamespace: workload.Namespace,
		}.String(),
	})
	if err != nil {
		return WorkloadVulnerabilities{}, err
	}
	reports := make(map[string]starboard.VulnerabilityScanResult)
	for _, item := range list.Items {
		if container, ok := item.Labels[kube.LabelContainerName]; ok {
			reports[container] = item.Report
		}
	}
	return reports, nil
}
