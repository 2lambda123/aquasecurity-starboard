package vulnerabilityreport

import (
	"context"

	"github.com/aquasecurity/starboard/pkg/apis/aquasecurity/v1alpha1"
	clientset "github.com/aquasecurity/starboard/pkg/generated/clientset/versioned"
	"github.com/aquasecurity/starboard/pkg/kube"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/labels"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/klog"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

// WorkloadVulnerabilities holds VulnerabilityReports for each container
// of a Kubernetes workload.
// Deprecated use a slice of VulnerabilityReports instead
type WorkloadVulnerabilities map[string]v1alpha1.VulnerabilityScanResult

type Writer interface {
	Write(context.Context, []v1alpha1.VulnerabilityReport) error
}

type Reader interface {
	FindByOwner(context.Context, kube.Object) ([]v1alpha1.VulnerabilityReport, error)
}

type ReadWriter interface {
	Reader
	Writer
}

type readWriter struct {
	client clientset.Interface
}

// NewReadWriter constructs a new ReadWriter which is using the client-go
// module for interacting with the Kubernetes API server.
func NewReadWriter(client clientset.Interface) ReadWriter {
	return &readWriter{
		client: client,
	}
}

func (s *readWriter) Write(ctx context.Context, reports []v1alpha1.VulnerabilityReport) error {
	for _, report := range reports {
		err := s.createOrUpdate(ctx, report)
		if err != nil {
			return err
		}
	}
	return nil
}

func (s *readWriter) createOrUpdate(ctx context.Context, report v1alpha1.VulnerabilityReport) error {
	existing, err := s.client.AquasecurityV1alpha1().VulnerabilityReports(report.Namespace).
		Get(ctx, report.Name, metav1.GetOptions{})

	if err == nil {
		klog.V(3).Infof("Updating VulnerabilityReport %q", report.Namespace+"/"+report.Name)
		deepCopy := existing.DeepCopy()
		deepCopy.Labels = report.Labels
		deepCopy.Report = report.Report

		_, err = s.client.AquasecurityV1alpha1().VulnerabilityReports(report.Namespace).
			Update(ctx, deepCopy, metav1.UpdateOptions{})
		return err
	}

	if errors.IsNotFound(err) {
		klog.V(3).Infof("Creating VulnerabilityReport %q", report.Namespace+"/"+report.Name)
		_, err = s.client.AquasecurityV1alpha1().VulnerabilityReports(report.Namespace).
			Create(ctx, &report, metav1.CreateOptions{})
		return err
	}

	return err
}

func (s *readWriter) FindByOwner(ctx context.Context, owner kube.Object) ([]v1alpha1.VulnerabilityReport, error) {
	list, err := s.client.AquasecurityV1alpha1().VulnerabilityReports(owner.Namespace).List(ctx, metav1.ListOptions{
		LabelSelector: labels.Set{
			kube.LabelResourceKind:      string(owner.Kind),
			kube.LabelResourceName:      owner.Name,
			kube.LabelResourceNamespace: owner.Namespace,
		}.String(),
	})
	if err != nil {
		return nil, err
	}
	return list.DeepCopy().Items, nil
}

type crReadWriter struct {
	client client.Client
	scheme *runtime.Scheme
}

// NewControllerRuntimeReadWriter constructs a new ReadWriter which is
// using the client package provided by the controller-runtime libraries for
// interacting with the Kubernetes API server.
func NewControllerRuntimeReadWriter(client client.Client, scheme *runtime.Scheme) ReadWriter {
	return &crReadWriter{
		client: client,
		scheme: scheme,
	}
}

func (s *crReadWriter) Write(ctx context.Context, reports []v1alpha1.VulnerabilityReport) error {
	for _, report := range reports {
		err := s.createOrUpdate(ctx, report)
		if err != nil {
			return err
		}
	}
	return nil
}

func (s *crReadWriter) createOrUpdate(ctx context.Context, report v1alpha1.VulnerabilityReport) error {
	var existing v1alpha1.VulnerabilityReport
	err := s.client.Get(ctx, types.NamespacedName{
		Name:      report.Name,
		Namespace: report.Namespace,
	}, &existing)

	if err == nil {
		copied := existing.DeepCopy()
		copied.Labels = report.Labels
		copied.Report = report.Report

		return s.client.Update(ctx, copied)
	}

	if errors.IsNotFound(err) {
		return s.client.Create(ctx, &report)
	}

	return err
}

func (s *crReadWriter) FindByOwner(ctx context.Context, owner kube.Object) ([]v1alpha1.VulnerabilityReport, error) {
	var list v1alpha1.VulnerabilityReportList

	err := s.client.List(ctx, &list, client.MatchingLabels{
		kube.LabelResourceKind:      string(owner.Kind),
		kube.LabelResourceNamespace: owner.Namespace,
		kube.LabelResourceName:      owner.Name,
	}, client.InNamespace(owner.Namespace))
	if err != nil {
		return nil, err
	}

	return list.DeepCopy().Items, nil
}
